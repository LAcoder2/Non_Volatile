
Module MainModule
    
    '**************************************************************************
    'twinBASIC XLL UDF Demo v1.0.1
    'by Jon Johnson
    'https://github.com/fafalone/TBXLLUDF
    'Based on the Generic example from the Excel SDK
    '
    'This addin registers two functions:
    '  TBXLLUDF_NumberName - Converts a whole number between 0 and MAXLONGLONG
    '         to its English name, e.g. 21 to Twenty One.
    '  TBXLLUDF_RomanNumeral - Converts a whole number between 1 and MAXLONG
    '         to a Roman numeral, e.g. 9 to IX.
    '
    'This is the main module containing the UDFs and event handlers.
    'The full Excel SDK and helper functions based on the Framework example
    'are in ExcelSDK.twin. 
    'The functions to compute the return value of the UDFs are in modFuncs.
    '
    'I've added a few custom helper functions but there's a ways to go in 
    'making this friendlier. I'll work on that in future demos of more
    'advanced functionality.
    '
    ' (17 Dec 2024) Version 1.0.2 - Bug fix for (unused in this project) SDK
    '       helper functions.
    ' (16 Dec 2024) Version 1.0.1 - Initial release
    '**************************************************************************
       
    
    'General API defs; you don't need the following if you use WinDevLib
    Private Const MAXLONGLONG As LongLong = 9223372036854775807^
    Private Const MAXLONG  = &H7fffffff  ' winnt

    Private xUDFNames() As XL12Ptr, UDFCount As Long
    [DllExport]
    Function xlAutoOpen() As Long
        Dim FuncName As String
        Dim xDLL As XL12Ptr
        
        FetchExcel12EntryPt()
        pExcel12p xlcAlert, , 2, GetXL12Str("Welcome to the tB XLL UDF Demo!"), GetXLInt12(1)
        
        pExcel12 xlGetName, 0, ByVal 0, xDLL
        
        ReDim xUDFNames(5)
        
        FuncName = "TBXLLUDF_NumberName"
        Excel12UDFRegistration xDLL, _
            /*Procedure     */ FuncName, _ 
            /*type_text     */ "UU", _
            /*function_text */ FuncName, _
            /*argument_text */ "Number to name", _
            /*macro_type    */ "1", _
            /*category      */ "tB XLL UDF Add-In", _
            /*shortcut_text */ , _
            /*help_topic    */ , _
            /*function_help */ "Returns the text name of a number, e.g. 1 to One", _
            /*argument1 help*/ "The number to name " '
        FuncName = "TBXLLUDF_RomanNumeral"
        Excel12UDFRegistration xDLL, _
                                FuncName, _ 
                                "UU", _
                                FuncName, _
                                "Number to convert", _
                                "1", _
                                "tB XLL UDF Add-In", , , _
                                "Returns the Roman numeral of a number, e.g. 9 to IX", _
                                "The number to convert "
        FuncName = "TBXLLUDF_GetType"
        Excel12UDFRegistration xDLL, _
                                FuncName, _ 
                                "UU", _
                                FuncName, , _
                                "1", , , , , _
                                vbNullString
        FuncName = "TBXLLUDF_VbaCallback"
        Excel12UDFRegistration(xDLL, _
                                FuncName, _ 
                                "UUQQQQ", _
                                FuncName, _
                                "reference,rowOff,colOff,heigth,width", _
                                "1", _
                                "tB XLL UDF Add-In", _
                                "", _
                                "", _
                                "Adds the arguments", _                        
                                "reference, rowOff, colOff, heigth, width, reference")
        
        FuncName = "Offset_nv"
        MsgBox "СМЕЩ2 регистрация: " & _
        Excel12UDFRegistration(xDLL, _
                                FuncName, _ 
                                "UUQQQQ", _
                                "СМЕЩ2", _
                                "reference,rowOff,colOff,heigth,width", _
                                "1", _
                                "tB XLL UDF Add-In", _
                                "", _
                                "Не волатильный налог функции СМЕЩ/OFFSET", _
                                "Adds the arguments", _                        
                                "reference, rowOff, colOff, heigth, width, reference")
        ' { L"FuncSum",
        ' L "UUUUUUUUUUUUUUUUUUUUUUUUUUUUUU", // up to 255 args in Excel 2007 And later,
        '                                    // upto 29 args in Excel 2003 And earlier versions
        ' L "FuncSum",
        ' L "number1,number2,...",
        ' L "1",
        ' L "Generic Add-In",
        ' L "",
        ' L "",
        ' L "Adds the arguments",
        ' L "Number1,number2,... are 1 to 29 arguments for which you want to sum."
        ' },
        
        ' // Register XllEcho functions.
        ' HelpRegister12(L "XllEcho", L"QQ", L"XllEcho", L"Anything");
        ' HelpRegister12(L "XllEchoA", L">QX", L"XllEchoA", L"Anything");
        FuncName = "XllEcho"
        Excel12UDFRegistration xDLL, FuncName, "QQ", FuncName, "Anything"
        
        FuncName = "XllEchoA"
        Excel12UDFRegistration(xDLL, FuncName, ">QX", FuncName, "Anything")
        ' MsgBox ">QX$: " & lret
        
        pExcel12 xlFree, 1, VarPtr(xDLL)
        
        Return 1
    End Function
    [DllExport]
    Private Function Excel12UDFRegistration(xDll As XL12Ptr, ParamArray params() As Variant) As Excel4ReturnCodes
        Dim funcdef() As XL12Ptr, i&, Ub&
        Dim lret As Excel4ReturnCodes, xDummy As XL12Num
        
        Ub = UBound(params)
        ReDim funcdef(Ub + 1)
        
        funcdef(0) = xDll
        For i = 0 To Ub
            funcdef(i + 1) = GetXL12StrPtr(CStr(params(i)))
        Next
                
        lret = pExcel12v(xlfRegister, xDummy, Ub + 1, funcdef)
        If lret = xlretSuccess Then
            Ub = UBound(xUDFNames)
            If Ub < UDFCount Then
                ReDim Preserve xUDFNames(UDFCount)
            End If
            xUDFNames(UDFCount) = funcdef(1)
            UDFCount += 1
        End If
        ' MsgBox lret
        Excel12UDFRegistration = lret
    End Function
    [DllExport]
    Private Sub UDFUnregister(UDFName As String)
        pExcel12p xlfSetName, ByVal 0, 1, GetXL12Str(UDFName) 'byval 0 on the stack looks like ByVal vbNullPtr
    End Sub
    [DllExport]
    Function xlAutoClose() As Long
        Dim i&
        
        For i = 0 To UBound(xUDFNames)
            pExcel12p xlfSetName, ByVal 0, 1, xUDFNames(i)
        Next
        
        Return 1
    End Function
    'Return the long name of the addin
    [DllExport]
    Function xlAddInManagerInfo12(xAction As XLOPER12) As LongPtr 'lpXLOPER12 
        Static xInfo As XL12Ptr
        Dim xIntAction As XL12Int
        
        pExcel12p xlCoerce, xIntAction, 2, xAction, GetXL12Int(xltypeInt)
        
        If xIntAction.lVal = 1 Then
            If xInfo.ptr Then Else _
                xInfo = GetXL12StrPtr("tB XLL Add-in")
        Else
            xInfo.xltype = xltypeErr
            xInfo.ptr = xlerrValue
        End If
                
        Return VarPtr(xInfo)
    End Function
    
    'Define our UDFs:     
    [DllExport]
    Function TBXLLUDF_NumberName(xInp As XLOPER12) As LongPtr 'LPXLOPER12
        Static xResult As XL12Ptr
        Dim llNum As LongLong, error As XloperErrorCodes
        
        error = XLOPER12ToLongLong(xInp, llNum)
        
        If (error <> -1) AndAlso (llNum <= 0) Then
            xResult.xltype = xltypeErr
            xResult.ptr = error
            Return VarPtr(xResult)
        End If
        
        xResult = GetXL12StrPtr(ConvertNumberToText(CStr(llNum)))
        
        Return VarPtr(xResult)
    End Function
    [DllExport]
    Function TBXLLUDF_RomanNumeral(xlIn As XLOPER12) As LongPtr 'LPXLOPER12
        Static xResult As XL12Ptr
        Dim llNum As LongLong, error As XloperErrorCodes
        
        error = XLOPER12ToLongLong(xlIn, llNum)
        
        If (error <> -1) Or (llNum <= 0) Then
            xResult.xltype = xltypeErr
            xResult.ptr = error
            Return VarPtr(xResult)
        End If
        
        xResult = GetXL12StrPtr(num_getroman(CStr(llNum)))
        
        Return VarPtr(xResult)
    End Function
    
    [DllExport]
    Function TBXLLUDF_GetType(xlIn As XL12Int) As LongPtr 'LPXLOPER12        
        
        xlIn = GetXL12Int(xlIn.xltype)
        
        Return VarPtr(xlIn)
    End Function
    
    Private Delegate Function VBACallBack_Deleg (oper As XLOPER12, ByVal lp1 As LongPtr, ByVal lp2 As LongPtr, ByVal lp3 As LongPtr, ByVal lp4 As LongPtr) As LongPtr
    Private VBACallBack As VBACallBack_Deleg
    [DllExport] 'Registering a vba callback function
    Sub VbaCallbackRegister(ByVal fnAddr As VBACallBack_Deleg)
        If fnAddr > 0 Then VBACallBack = fnAddr
    End Sub
    [DllExport] 'A transit function that redirects a call to an external function registered from the vba host.
    Function TBXLLUDF_VbaCallback(xRef As XLOPER12, ByVal lp1 As LongPtr, ByVal lp2 As LongPtr, ByVal lp3 As LongPtr, ByVal lp4 As LongPtr) As LongPtr 'LPXLOPER12
        Static xResult As XL12Ptr
        Dim dNum As Double, error As XloperErrorCodes
        
        If VBACallBack Then
        Else
            xResult = GetXL12StrPtr("Missing registered Callback function")
            xResult.xltype = xltypeStr Or xlbitDLLFree
            Return VarPtr(xResult)
        End If
        
        Return VBACallBack(xRef, lp1, lp2, lp3, lp4)
    End Function
    [DllExport] 'Non-volatile analogue of the Offset sheet function
    Function Offset_nv(xRef As XLOPER12, xRowOff As XLOPER12, xColOff As XLOPER12, xHeight As XLOPER12, xWidth As XLOPER12) As LongPtr
        'Dim lret As Long = '_
        pExcel12p(xlfOffset, xRef, 5, xRef, xRowOff, xColOff, xHeight, xWidth)
    
        Return VarPtr(xRef)
    End Function
    
    Private Function XLOPER12ToLongLong(XL12Inp As XLOPER12, llOut As LongLong) As XloperErrorCodes
        Dim xInt As XL12Int, dNum As Double
        Dim error As XloperErrorCodes
                
        Select Case XL12Inp.xltype
        Case xltypeNum
            dNum = GetDbl(XL12Inp)
            If dNum <= MAXLONGLONG Then llOut = dNum
        Case xltypeInt
            llOut = GetLng(XL12Inp)
        Case xltypeSRef
            If pExcel12p(xlCoerce, xInt, 2, XL12Inp, GetXLInt12(xltypeInt)) = xlretSuccess Then
                error = -1
                llOut = xInt.lVal
            ' Else: pExcel12p xlFree, , 1, xInt
            End If
        Case Else
            error = xlerrValue
        End Select
        
        Return error
    End Function
    Private Function XLOPER12ToDobule(XL12Inp As XLOPER12, dOut As Double) As XloperErrorCodes
        Dim xNum As XL12Num
        Dim error As XloperErrorCodes = -1
                
        Select Case XL12Inp.xltype
        Case xltypeNum: dOut = GetDbl(XL12Inp)
        Case xltypeInt: dOut = GetLng(XL12Inp)
        Case xltypeSRef
            If pExcel12p(xlCoerce, xNum, 2, XL12Inp, GetXLInt12(xltypeNum)) = xlretSuccess Then
                error = -1
                dOut = xNum.num
            End If
            ' pExcel12 xlFree, 1, VarPtr(xNum)
        Case Else: error = xlerrValue
        End Select
        
        Return error
    End Function
    
    '########################Async/Multithread UDF Example##########################
    'Sorce - 
    ' LPXLOPER12 WINAPI XllEcho(LPXLOPER12 oper)
    ' {
    '     // Simulate a long operation.
    '     Sleep(1000);

    '     if (oper->xltype & xltypeNum)
    '         oper->val.num *= 2;
    '     return oper;
    ' }
    [DllExport]'Example of a simple synchronous UDF
    Function XllEcho(oper As XLOPER12) As LongPtr
        Dim dNum As Double, lerror As XloperErrorCodes
        
        Sleep 1000          '// Simulate a long operation.
        
        If oper.xltype And xltypeNum Then
            dNum = GetDbl(oper)
            PutDbl(oper) = dNum * 2
        Else
            lerror = XLOPER12ToDobule(oper, dNum)
            If lerror = -1 Then
                PutDbl(oper) = dNum
            Else
                oper.xltype = xltypeErr
                PutLng(oper) = lerror
            End If
        End If
        
        Return VarPtr(oper)
    End Function
    ' void WINAPI XllEchoA(LPXLOPER12 oper, LPXLOPER12 asyncHandle)
    ' {
    '     // Point to the arguments from a pointer array that will be freed by 
    '     // XllEchoSetReturn.
    '     LPXLOPER12* argsArray = new LPXLOPER12[2];
    '     if (argsArray == NULL)
    '     {
    '         AsyncStubFailHelper(asyncHandle);
    '         return;
    '     }

    '     argsArray[0] = TempOper12(oper);
    '     if (argsArray[0] == NULL)
    '     {
    '         delete argsArray;
    '         AsyncStubFailHelper(asyncHandle);
    '     }
    '     argsArray[1] = TempOper12(asyncHandle);
    '     if (argsArray[1] == NULL)
    '     {
    '         xlAutoFree12(argsArray[0]);
    '         delete argsArray;
    '         AsyncStubFailHelper(asyncHandle);
    '     }

    '     // Simulate an external async operation-start a thread and return.
    '     if (CreateThread(NULL, 0, XllEchoSetReturn, argsArray, 0, NULL) == NULL)
    '     {
    '         xlAutoFree12(argsArray[1]);
    '         xlAutoFree12(argsArray[0]);
    '         delete argsArray;
    '         AsyncStubFailHelper(asyncHandle);
    '     }
    ' }
    [DllExport] 'Example of a thread-safe asynchronous UDF
    Sub XllEchoA(oper As XLOPER12, asyncHandle As XLOPER12)
'         // Point to the arguments from a pointer array that will be freed by 
'         // XllEchoSetReturn.
        'LPXLOPER12* argsArray = new LPXLOPER12[2];
        Dim argsArray() As XLOPER12 'LPXLOPER12
        Dim pSAargs As LongPtr ' pArgs() As LongPtr
        
        ReDim argsArray(1)
        argsArray(0) = oper         'argsArray[0] = TempOper12(oper);
        argsArray(1) = asyncHandle  'argsArray[1] = TempOper12(asyncHandle);        
        '// Simulate an external async operation-start a thread and return.
        ' MsgBox "Запускаем поток!"
        ' ReDim pArgs(1) As LongPtr
        ' pArgs(0) = VarPtr(oper)
        ' pArgs(1) = VarPtr(asyncHandle)
        
        MovePtr(pSAargs, argsArray) 'transferring memory ownership to a thread function
        If CreateThread(ByVal vbNullPtr, 0, AddressOf XllEchoSetReturn, ByVal pSAargs, 0, ByVal 0) = 0 Then
            MsgBox "The stream did not start"
            pExcel12 xlFree, 1, VarPtr(oper)
            AsyncStubFailHelper asyncHandle
        End If
        ' BeepApi 850, 400
        Exit Sub
    End Sub
    ' DWORD WINAPI XllEchoSetReturn(LPVOID args)
    ' {
    '     LPXLOPER12* opers = (LPXLOPER12*)args;
    '     XLOPER12 xlResult;

    '     // Simulate waiting for a long external operation.
    '     Sleep(1000);
    '     if (opers[0]->xltype & xltypeNum)
    '         opers[0]->val.num *= 2;

    '     int retval = Excel12(xlAsyncReturn, &xlResult, 2, opers[1], opers[0]);

    '     // Free the passed pointer array
    '     // (Excel itself calls xlAutoFree12 to free the XLOPERs, since they have 
    '     // xlbitDLLFree).  
    '     delete opers;

    '     ExitThread(0);
    '     return 0;
    ' }
    Function XllEchoSetReturn(ByVal pSAargs As LongPtr) As Long
        Dim xResult As XLOPER12, opers() As XLOPER12, pArgs() As LongPtr
        Dim dNum As Double, lerror As XloperErrorCodes, retval As Long
        
        PutPtr(opers) = pSAargs 'taking ownership of transferred memory
        
        Sleep 1000            '// Simulate waiting for a long external operation.
        
        With opers(0)
            If .xltype And xltypeNum Then
                dNum = GetDbl(.val)
                PutDbl(.val) = dNum * 2
            Else
                lerror = XLOPER12ToDobule(opers(0), dNum)
                If lerror = -1 Then
                    PutDbl(.val) = dNum * 2
                Else
                    .xltype = xltypeErr
                    .val = lerror
                End If
            End If
        End With
        
        ' CType(Of Multip_Deleg)(AddressOf Multip)(pArgs(0))
        
        retval = pExcel12p(xlAsyncReturn, xResult, 2, opers(1), opers(0))
        ' retval = pExcel12p(xlAsyncReturn, xResult, 2, ByVal pArgs(1), ByVal pArgs(0))
        ' Erase opers       'Just in case, you can clear the data before exiting the stream.
        ' ExitThread(0)
    End Function
    
    ' Private Sub TestMultipDeleg()
    '     Dim xNum As XLOPER12
    '     xNum.xltype = xltypeInt
    '     PutLng(xNum) = 100
    '     CType(Of Multip_Deleg)(AddressOf Multip)(VarPtr(xNum))
    ' End Sub
    ' Private Delegate Sub Multip_Deleg (ByVal pxNum As LongPtr)
    ' Private Sub Multip(xNum As XLOPER12)
    '     Dim lerror As XloperErrorCodes
    '     Dim dNum As Double
        
    '     With xNum
    '         If .xltype And xltypeNum Then
    '             dNum = GetDbl(.val)
    ' '           PutDbl(.val) = dNum * 2
    '         Else
    '             lerror = XLOPER12ToDobule(xNum, dNum)
    '             If lerror = -1 Then
    '                 PutDbl(.val) = dNum * 2
    '             Else
    '                 .xltype = xltypeErr
    '                 .val = lerror
    '                 MsgBox "error!"
    '             End If
    '       End If
    '     End With
    ' End Sub
    
    'https://github.com/wasgsd/dev/blob/4c6139ad431bb56ce91e080e76062b604f5c9e4f/DDxll/DDxll.cpp
    ' //void AsyncStubFailHelper(LPXLOPER12 asyncHandle)
    ' //{
    ' //    //an error handler with no heap/thread operations.  
    ' //    //used to send back #VALUE! when an async stub fails
    ' //    XLOPER12 operResult;
    ' //
    ' //    XLOPER12 operErr;
    ' //    operErr.xltype = xltypeErr;
    ' //    operErr.val.err = xlerrValue;
    ' //
    ' //    Excel12(xlAsyncReturn, &operResult, 2, asyncHandle, &operErr);
    ' //}
    Sub AsyncStubFailHelper(asyncHandle As XLOPER12)
        '//an error handler With no heap/thread operations.  
        '//used to send back #VALUE! when an async stub fails
        Dim operResult As XLOPER12
        Dim operErr As XL12Int
        
        operErr.xltype = xltypeErr
        operErr.lVal = xlerrValue
        
        pExcel12p(xlAsyncReturn, operResult, 2, asyncHandle, operErr)
    End Sub
    
    Private Sub Excel12UDFRegistration2(xDll As XL12Ptr, Procedure$, Optional type_text$, Optional function_text$, _
                                        Optional argument_text$, Optional macro_type$, Optional category$, Optional shortcut_text$, _
                                        Optional help_topic$, Optional function_help$, Optional arguments_help As Variant)
        Dim i&, CntArgs&, isArr As Boolean, funcdef() As XL12Ptr
        If Not IsMissing(arguments_help) Then
            isArr = IsArray(arguments_help)
            If isArr Then
                CntArgs = UBound(arguments_help) + 1
            Else: CntArgs = 1
            End If
        End If
        ReDim funcdef(9 + CntArgs)
        funcdef(0) = xDll
        funcdef(1) = GetXL12StrPtr(Procedure)
        funcdef(2) = GetXL12StrPtr(type_text)
        funcdef(3) = GetXL12StrPtr(function_text)
        funcdef(4) = GetXL12StrPtr(argument_text)
        funcdef(5) = GetXL12StrPtr(macro_type)
        funcdef(6) = GetXL12StrPtr(category)
        funcdef(7) = GetXL12StrPtr(shortcut_text)
        funcdef(8) = GetXL12StrPtr(help_topic)
        funcdef(9) = GetXL12StrPtr(function_help)
        If CntArgs Then
            If isArr Then
                For i = 0 To CntArgs - 1
                    funcdef(10 + i) = GetXL12StrPtr(CStr(arguments_help(i)))
                Next
            Else
                funcdef(10) = GetXL12StrPtr(CStr(arguments_help))
            End If
        End If
        Dim lret As Long, xDummy As XL12Num
        lret = pExcel12v(xlfRegister, xDummy, 10 + CntArgs, funcdef)
        ' MsgBox lret
    End Sub
    
    ' Private Delegate Function VBACallBack_Deleg (dNum As Double) As String
    ' Private VBACallBack As VBACallBack_Deleg
    ' [DllExport]
    ' Sub VbaCallbackRegister(ByVal fnAddr As VBACallBack_Deleg)
    '     If fnAddr > 0 Then VBACallBack = fnAddr
    ' End Sub
    ' [DllExport]
    ' Function TBXLLUDF_VbaCallback(xlIn As XLOPER12) As LongPtr 'LPXLOPER12
    '     Static xResult As XL12Ptr
    '     Dim dNum As Double, error As XloperErrorCodes
        
    '     If VBACallBack Then
    '     Else
    '         xResult = GetXL12StrPtr("Missing registered Callback function")
    '         Return VarPtr(xResult)
    '     End If
        
    '     error = XLOPER12ToDobule(xlIn, dNum)
    '     If (error <> -1) Then
    '         xResult.xltype = xltypeErr
    '         xResult.ptr = error
    '         Return VarPtr(xResult)
    '     End If
        
    '     xResult = GetXL12StrPtr(VBACallBack(dNum))
        
    '     Return VarPtr(xResult)
    ' End Function        
' void HelpRegister12(XCHAR* procedure, XCHAR* typeText, XCHAR* functionText, XCHAR* argumentText)
' {
'     // Create XLOPER12s.
'     XLOPER12 xResult;
'     XLOPER12 xModuleText;
'     Excel12(xlGetName, &xModuleText, 0);
'     LPXLOPER12 pxProcedure = TempStr12(procedure);
'     LPXLOPER12 pxTypeText = TempStr12(typeText);
'     LPXLOPER12 pxFunctionText = TempStr12(functionText);
'     LPXLOPER12 pxArgumentText = TempStr12(argumentText);

'     // Register the Function.
'     Excel12(xlfRegister, &xResult, 5, &xModuleText, pxProcedure, 
'         pxTypeText, pxFunctionText, pxArgumentText);

'     // Clean up the XLOPER12.
'     Excel12(xlFree, &xResult, 1, &xModuleText);

'     xlAutoFree12(pxProcedure);
'     xlAutoFree12(pxTypeText);
'     xlAutoFree12(pxFunctionText);
'     xlAutoFree12(pxArgumentText);
' }
    ' Private Sub HelpRegister12(xModuleText As XL12Ptr, procedure$, typeText$, functionText$, argumentText$)
    '     Dim xResult As XLOPER12, lRet As Long
        
    '     lRet = pExcel12p(xlfRegister, xResult, 5, xModuleText, _
    '                             GetXL12StrPtr(procedure), _ 
    '                             GetXL12StrPtr(typeText), _
    '                             GetXL12StrPtr(functionText), _
    '                             GetXL12StrPtr(argumentText))
    '     MsgBox "Async Register" & vbCr & lRet
    ' End Sub    
    ' [DllExport]
    ' Function xlAddInManagerInfo12(xAction As XLOPER12) As LongPtr 'LPXLOPER12 
    '     Static xInfo(0) As XLOPER12, xIntAction(0) As XLOPER12
    '     Dim xTmp(1) As XLOPER12
    '     xTmp(0) = xAction
    '     xTmp(1) = GetXLInt12(xltypeInt)
    '     Excel12v(xlCoerce, xIntAction(0), 2, xTmp)
    '     Dim w As Long
    '     GetMem4_ xIntAction(0), w
    '     If w = 1 Then
    '         xInfo(0) = GetXLString12("tB XLL Add-in")
    '     Else
    '         xInfo(0).xltype = xltypeErr
    '         GetMem4_ xlerrValue, xInfo(0)
    '     End If
        
    '     Return VarPtr(xInfo(0))
    ' End Function    
    ' [DllExport]
    ' Private Sub Excel12UDFRegistration2(Procedure$, Optional type_text$, Optional function_text$, _
    '                                     Optional argument_text$, Optional macro_type$, Optional category$, Optional shortcut_text$, _
    '                                     Optional help_topic$, Optional function_help$, Optional arguments_help As Variant)
    '     Dim xDLL As XL12Ptr, funcdef() As XL12Ptr
    '     Dim i&, CntArgs&, isArr As Boolean
    '     ' Dim xDLL(0) As XLOPER12, dummy(0) As XLOPER12        
    '     ' Excel12v(xlGetName, xDLL(0), 0, dummy) 'MsgBox "xDll 2: " &         
    '     pExcel12 xlGetName, , , xDLL
        
    '     If Not IsMissing(arguments_help) Then
    '         isArr = IsArray(arguments_help)
    '         If isArr Then
    '             CntArgs = UBound(arguments_help) + 1
    '         Else: CntArgs = 1
    '         End If
    '     End If
    '     If Len(function_text) = 0 Then function_text = Procedure
    '     ReDim funcdef(9 + CntArgs)
    '     funcdef(0) = xDLL'(0)
    '     funcdef(1) = GetXL12StrPtr(Procedure)
    '     funcdef(2) = GetXL12StrPtr(type_text)
    '     funcdef(3) = GetXL12StrPtr(function_text)
    '     funcdef(4) = GetXL12StrPtr(argument_text)
    '     funcdef(5) = GetXL12StrPtr(macro_type)
    '     funcdef(6) = GetXL12StrPtr(category)
    '     funcdef(7) = GetXL12StrPtr(shortcut_text)
    '     funcdef(8) = GetXL12StrPtr(help_topic)
    '     funcdef(9) = GetXL12StrPtr(function_help)
    '     If CntArgs Then
    '         If isArr Then
    '             For i = 0 To CntArgs - 1
    '                 funcdef(10 + i) = GetXL12StrPtr(CStr(arguments_help(i)))
    '             Next
    '         Else
    '             funcdef(10) = GetXL12StrPtr(CStr(arguments_help))
    '         End If
    '     End If
    '     pExcel12v(xlfRegister, vbNullPtr, 10 + CntArgs, funcdef)
        
    '     ' Excel12v(xlFree, vbNullPtr, 1, xDLL)
    '     ' pExcel12 xlFree, 1, VarPtr(xDLL)
    '     pExcel12p xlFree, , 1, xDLL
    ' End Sub
    ' [DllExport]
    
    ' Function TBXLLUDF_NumberName(xlIn As XLOPER12) As LongPtr 'LPXLOPER12
    '     Static xResult As XLOPER12
    '     Dim llNum As LongLong
    '     Dim error As XloperErrorCodes
        
    '     error = XLOPER12ToLongLong(xlIn, llNum)
        
    '     If (error <> -1) AndAlso (llNum <= 0) Then
    '         xResult.xltype = xltypeErr
    '         PutMem4_ xResult, error
    '         Return VarPtr(xResult)
    '     End If
        
    '     xResult = GetXLString12(ConvertNumberToText(CStr(llNum)))
    '     Return VarPtr(xResult)
    ' End Function
    ' Private Function XLOPER12ToLongLong(XL12Inp As XLOPER12, llOut As LongLong) As XloperErrorCodes
    '     Dim xlt(0) As XLOPER12
    '     Dim xle() As XLOPER12: ReDim xle(1)
    '     Dim dNum As Double
    '     Dim error As XloperErrorCodes = -1
                
    '     Select Case XL12Inp.xltype
    '     Case xltypeNum
    '         dNum = Xloper12NumValue(XL12Inp)
    '         If dNum <= MAXLONGLONG Then llOut = dNum
    '     Case xltypeInt
    '         llOut = Xloper12IntValue(XL12Inp)
    '     Case xltypeSRef
    '         xle(0) = XL12Inp
    '         xle(1) = GetXLInt12(xltypeInt)
    '         error = Excel12v(xlCoerce, xlt(0), 2, xle)
    '         If error = 0 Then
    '             error = -1
    '             llOut = Xloper12IntValue(xlt(0))
    '         End If
    '         Excel12v(xlFree, vbNullPtr, 1, xlt)
    '     Case Else
    '         error = xlerrValue
    '     End Select
        
    '     Return error
    ' End Function
    ' Private Function XLOPER12ToDobule(XL12Inp As XLOPER12, dOut As Double) As XloperErrorCodes
    '     Dim xlt(0) As XLOPER12
    '     Dim xle() As XLOPER12: ReDim xle(1)
    '     Dim error As XloperErrorCodes = -1
                
    '     Select Case XL12Inp.xltype
    '     Case xltypeNum
    '         dOut = Xloper12NumValue(XL12Inp)
    '     Case xltypeInt
    '         dOut = Xloper12IntValue(XL12Inp)
    '     Case xltypeSRef
    '         xle(0) = XL12Inp
    '         xle(1) = GetXLInt12(xltypeInt)
    '         error = Excel12v(xlCoerce, xlt(0), 2, xle)
    '         If error = 0 Then
    '             error = -1
    '             dOut = Xloper12IntValue(xlt(0))
    '         End If
    '         Excel12v(xlFree, vbNullPtr, 1, xlt)
    '     Case Else
    '         error = xlerrValue
    '     End Select
        
    '     Return error
    ' End Function
    
End Module
